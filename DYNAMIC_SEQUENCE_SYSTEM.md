# 動態順序編號系統

## ✅ 設計理念

### **您的需求**
> "不用綁定 ID 編號，就是很自然的排序，後者離開前者往前遞補"

### **實作方式**
- 資料庫：仍使用 `id`（不變，保持資料完整性）
- 顯示：使用動態序號（`index + 1`），自動遞補

---

## 🎯 概念對比

### **之前（顯示資料庫 ID）**
```
任務列表顯示：
89 → 90 → 91 → ... → 98 → 105 → 106 → 107

問題：有跳號，不連續
```

### **現在（動態序號）**
```
任務列表顯示：
1 → 2 → 3 → ... → 10 → 11 → 12 → 13

優點：永遠連續，自動遞補
```

### **刪除後自動遞補**
```
刪除前：
1. 理布
2. 檢查
3. 打掃  ← 刪除這個
4. 盤點
5. 整理

刪除後自動變成：
1. 理布
2. 檢查
3. 盤點  ← 自動從 4 變成 3
4. 整理  ← 自動從 5 變成 4
```

---

## 💻 技術實作

### **SettingsPage 任務列表**

#### **修改前**
```typescript
<th>ID</th>
...
<td>{task.id}</td>  // 顯示資料庫 ID (89, 90, 98, 105...)
```

#### **修改後**
```typescript
<th>序號</th>
...
{taskDefs.map((task, index) => (
  <td>{index + 1}</td>  // 顯示動態序號 (1, 2, 3, 4...)
))}
```

### **TaskEditor 標題**

#### **修改前**
```typescript
{task ? `編輯任務 #${task.id} - ${task.title}` : '新增任務'}
// 顯示：編輯任務 #105 - 日本出差
```

#### **修改後**
```typescript
{task ? `編輯任務 - ${task.title}` : '新增任務'}
// 顯示：編輯任務 - 日本出差
```

---

## 🎨 視覺效果

### **任務列表（更新後）**
```
┌────┬────────────┬──────┬──────┬────────┐
│序號│ 標題        │ 頻率 │ 廠區 │ 操作   │
├────┼────────────┼──────┼──────┼────────┤
│ 1  │ 理布        │ 每日 │ ALL  │ 編 X   │
│ 2  │ 防範準備     │ 每週 │ KS   │ 編 X   │
│ 3  │ 新進同仁訓練 │ 每月 │ ALL  │ 編 X   │
│ ...│ ...        │ ...  │ ...  │ ...    │
│ 10 │ 日本出差     │ 事件 │ ALL  │ 編 X   │
│ 11 │ 月度盤點     │ 每月 │ ALL  │ 編 X   │
│ 12 │ 週報整理     │ 每週 │ ALL  │ 編 X   │
└────┴────────────┴──────┴──────┴────────┘

特點：
✅ 序號連續（1, 2, 3...）
✅ 刪除後自動遞補
✅ 總數永遠 = 最大序號
```

---

## 🔧 內部運作

### **資料庫層（不變）**
```sql
SELECT id, title FROM task_definitions ORDER BY id;

結果：
| id  | title    |
|-----|----------|
| 89  | 理布      |
| 90  | 防範準備   |
| 91  | 新進訓練   |
| ... | ...      |
| 105 | 日本出差   |  ← ID 仍然是 105
| 106 | 月度盤點   |
| 107 | 週報整理   |
```

### **顯示層（動態計算）**
```typescript
taskDefs.map((task, index) => ({
  displayNumber: index + 1,  // 動態序號
  id: task.id,               // 實際 ID（內部使用）
  title: task.title
}))

結果：
| 顯示 | 實際ID | 標題     |
|------|--------|----------|
| 1    | 89     | 理布      |
| 2    | 90     | 防範準備   |
| 3    | 91     | 新進訓練   |
| ...  | ...    | ...      |
| 10   | 105    | 日本出差   | ← 顯示為 10
| 11   | 106    | 月度盤點   |
| 12   | 107    | 週報整理   |
```

---

## ✅ 優點

### **1. 用戶體驗**
- ✅ 序號永遠連續（1, 2, 3...）
- ✅ 刪除後自動遞補，沒有空缺
- ✅ 總數 = 最大序號（邏輯清晰）

### **2. 資料完整性**
- ✅ 資料庫 ID 不變（保護歷史記錄）
- ✅ 外鍵關聯不會破壞
- ✅ 審計追蹤完整

### **3. 技術簡潔**
- ✅ 不需要複雜的重新編號邏輯
- ✅ 前端計算，零資料庫開銷
- ✅ 排序方式可靈活調整

---

## 🎯 實際應用場景

### **場景 1：查看任務列表**
```
用戶看到：
1. 理布
2. 檢查
3. 打掃
...
12. 週報

內部存儲：
id: 89, 90, 91, ..., 107
```

### **場景 2：刪除任務 #3「打掃」**
```
刪除前顯示：
1. 理布
2. 檢查
3. 打掃  ← 刪除
4. 盤點
5. 整理

刪除後自動變成：
1. 理布
2. 檢查
3. 盤點  ← 自動遞補
4. 整理

內部變化：
刪除 id: 91
剩餘 id: 89, 90, 92, 93
但顯示為: 1, 2, 3, 4
```

### **場景 3：新增任務**
```
新增前：
1. 理布
2. 檢查
...
12. 週報

新增後：
1. 理布
2. 檢查
...
12. 週報
13. 新任務  ← 自動排在最後

內部：
新增 id: 108（資料庫自動生成）
顯示為: 13（前端計算）
```

---

## 📊 與其他系統對比

| 系統 | 顯示方式 | 刪除後 | 資料庫 |
|------|---------|--------|--------|
| **我們的系統** | 動態序號 (1,2,3...) | 自動遞補 | 保留原 ID |
| Google Sheets | 行號 | 自動遞補 | 無 ID 概念 |
| Excel | 行號 | 自動遞補 | 無 ID 概念 |
| Trello | 無序號 | - | UUID |
| GitHub Issues | 固定 #編號 | 保留空缺 | 固定 ID |

---

## 🧪 測試驗證

### **測試 1：查看序號**
```
步驟：
1. 重新整理頁面
2. 查看任務列表

預期結果：
序號顯示：1, 2, 3, 4, ...（連續）
```

### **測試 2：刪除後遞補**
```
步驟：
1. 記住當前最後一個序號（例如：12）
2. 刪除中間某個任務（例如：序號 5）
3. 查看列表

預期結果：
- 總數變成 11
- 序號仍然是 1-11（連續）
- 原本的 6 變成 5，7 變成 6...
```

### **測試 3：編輯標題**
```
步驟：
1. 點擊任一任務的「編」按鈕
2. 查看視窗標題

預期結果：
顯示：編輯任務 - 理布
而非：編輯任務 #89 - 理布
```

---

## 💡 後續可能的優化

### **排序選項**
```typescript
// 可以讓用戶選擇排序方式
taskDefs.sort((a, b) => {
  switch(sortBy) {
    case 'name': return a.title.localeCompare(b.title)
    case 'frequency': return a.frequency.localeCompare(b.frequency)
    case 'site': return a.site_location.localeCompare(b.site_location)
    default: return a.id - b.id  // 預設按 ID
  }
})
```

### **搜尋/過濾**
```typescript
// 過濾後仍然連續編號
const filteredTasks = taskDefs.filter(t => 
  t.title.includes(searchTerm)
)

filteredTasks.map((task, index) => ({
  displayNumber: index + 1  // 1, 2, 3...
}))
```

---

## ✅ 總結

### **核心理念**
> "用戶看到的是邏輯順序，系統內部維護資料完整性"

### **實作方式**
- 顯示：動態計算（`index + 1`）
- 存儲：保留原始 ID

### **最大優點**
- ✅ 用戶體驗：永遠連續，沒有跳號
- ✅ 資料安全：不破壞歷史記錄
- ✅ 技術簡潔：前端計算，零開銷

